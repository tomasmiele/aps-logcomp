Terminals which are not used

   COMMA


Grammar

    0 $accept: program $end

    1 program: /* empty */
    2        | program item

    3 item: declaration
    4     | statement

    5 declaration: var_decl
    6            | const_decl

    7 var_decl: LET IDENT COLON type opt_init SEMI

    8 const_decl: CONST IDENT COLON type ASSIGN expression SEMI

    9 type: KW_INT
   10     | KW_BOOL

   11 opt_init: /* empty */
   12         | ASSIGN expression

   13 statement: block
   14          | assign SEMI
   15          | if_stmt
   16          | while_stmt
   17          | for_stmt
   18          | io_stmt
   19          | event_stmt
   20          | BREAK SEMI
   21          | CONTINUE SEMI
   22          | SEMI

   23 block: LBRACE block_items RBRACE

   24 block_items: /* empty */
   25            | block_items declaration
   26            | block_items statement

   27 assign: lvalue ASSIGN expression

   28 lvalue: IDENT

   29 if_stmt: IF LPAREN expression RPAREN statement
   30        | IF LPAREN expression RPAREN statement ELSE statement

   31 while_stmt: WHILE LPAREN expression RPAREN statement

   32 for_stmt: FOR LPAREN for_init SEMI opt_expr SEMI opt_expr RPAREN statement

   33 for_init: /* empty */
   34         | LET IDENT COLON type opt_init
   35         | lvalue ASSIGN expression

   36 opt_expr: /* empty */
   37         | expression

   38 io_stmt: PRINT LPAREN expression RPAREN SEMI
   39        | OUT LPAREN expression RPAREN SEMI
   40        | READ LPAREN sensor_ref RPAREN SEMI

   41 event_stmt: EVERY INT_LIT MS block
   42           | WHEN LPAREN expression RPAREN block

   43 sensor_ref: TEMP
   44           | DOOROPEN
   45           | CLOCK_MS

   46 expression: logical_or

   47 logical_or: logical_and
   48           | logical_or OR logical_and

   49 logical_and: equality
   50            | logical_and AND equality

   51 equality: relational
   52         | equality EQ relational
   53         | equality NEQ relational

   54 relational: additive
   55           | relational LT additive
   56           | relational LE additive
   57           | relational GT additive
   58           | relational GE additive

   59 additive: multiplicative
   60         | additive PLUS multiplicative
   61         | additive MINUS multiplicative

   62 multiplicative: unary
   63               | multiplicative STAR unary
   64               | multiplicative SLASH unary
   65               | multiplicative MOD unary

   66 unary: primary
   67      | NOT unary
   68      | MINUS unary

   69 primary: INT_LIT
   70        | TRUE_LIT
   71        | FALSE_LIT
   72        | IDENT
   73        | sensor_ref
   74        | LPAREN expression RPAREN


Terminals, with rules where they appear

$end (0) 0
error (256)
LET (258) 7 34
CONST (259) 8
KW_INT (260) 9
KW_BOOL (261) 10
TRUE_LIT (262) 70
FALSE_LIT (263) 71
IF (264) 29 30
ELSE (265) 30
WHILE (266) 31
FOR (267) 32
BREAK (268) 20
CONTINUE (269) 21
PRINT (270) 38
OUT (271) 39
READ (272) 40
EVERY (273) 41
WHEN (274) 42
MS (275) 41
TEMP (276) 43
DOOROPEN (277) 44
CLOCK_MS (278) 45
IDENT (279) 7 8 28 34 72
INT_LIT (280) 41 69
EQ (281) 52
NEQ (282) 53
LE (283) 56
GE (284) 58
LT (285) 55
GT (286) 57
AND (287) 50
OR (288) 48
ASSIGN (289) 8 12 27 35
PLUS (290) 60
MINUS (291) 61 68
STAR (292) 63
SLASH (293) 64
MOD (294) 65
NOT (295) 67
LPAREN (296) 29 30 31 32 38 39 40 42 74
RPAREN (297) 29 30 31 32 38 39 40 42 74
LBRACE (298) 23
RBRACE (299) 23
COMMA (300)
SEMI (301) 7 8 14 20 21 22 32 38 39 40
COLON (302) 7 8 34
UMINUS (303)
NO_ELSE (304)


Nonterminals, with rules where they appear

$accept (50)
    on left: 0
program (51)
    on left: 1 2, on right: 0 2
item (52)
    on left: 3 4, on right: 2
declaration (53)
    on left: 5 6, on right: 3 25
var_decl (54)
    on left: 7, on right: 5
const_decl (55)
    on left: 8, on right: 6
type (56)
    on left: 9 10, on right: 7 8 34
opt_init (57)
    on left: 11 12, on right: 7 34
statement (58)
    on left: 13 14 15 16 17 18 19 20 21 22, on right: 4 26 29 30 31
    32
block (59)
    on left: 23, on right: 13 41 42
block_items (60)
    on left: 24 25 26, on right: 23 25 26
assign (61)
    on left: 27, on right: 14
lvalue (62)
    on left: 28, on right: 27 35
if_stmt (63)
    on left: 29 30, on right: 15
while_stmt (64)
    on left: 31, on right: 16
for_stmt (65)
    on left: 32, on right: 17
for_init (66)
    on left: 33 34 35, on right: 32
opt_expr (67)
    on left: 36 37, on right: 32
io_stmt (68)
    on left: 38 39 40, on right: 18
event_stmt (69)
    on left: 41 42, on right: 19
sensor_ref (70)
    on left: 43 44 45, on right: 40 73
expression (71)
    on left: 46, on right: 8 12 27 29 30 31 35 37 38 39 42 74
logical_or (72)
    on left: 47 48, on right: 46 48
logical_and (73)
    on left: 49 50, on right: 47 48 50
equality (74)
    on left: 51 52 53, on right: 49 50 52 53
relational (75)
    on left: 54 55 56 57 58, on right: 51 52 53 55 56 57 58
additive (76)
    on left: 59 60 61, on right: 54 55 56 57 58 60 61
multiplicative (77)
    on left: 62 63 64 65, on right: 59 60 61 63 64 65
unary (78)
    on left: 66 67 68, on right: 62 63 64 65 67 68
primary (79)
    on left: 69 70 71 72 73 74, on right: 66


state 0

    0 $accept: . program $end

    $default  reduce using rule 1 (program)

    program  go to state 1


state 1

    0 $accept: program . $end
    2 program: program . item

    $end      shift, and go to state 2
    LET       shift, and go to state 3
    CONST     shift, and go to state 4
    IF        shift, and go to state 5
    WHILE     shift, and go to state 6
    FOR       shift, and go to state 7
    BREAK     shift, and go to state 8
    CONTINUE  shift, and go to state 9
    PRINT     shift, and go to state 10
    OUT       shift, and go to state 11
    READ      shift, and go to state 12
    EVERY     shift, and go to state 13
    WHEN      shift, and go to state 14
    IDENT     shift, and go to state 15
    LBRACE    shift, and go to state 16
    SEMI      shift, and go to state 17

    item         go to state 18
    declaration  go to state 19
    var_decl     go to state 20
    const_decl   go to state 21
    statement    go to state 22
    block        go to state 23
    assign       go to state 24
    lvalue       go to state 25
    if_stmt      go to state 26
    while_stmt   go to state 27
    for_stmt     go to state 28
    io_stmt      go to state 29
    event_stmt   go to state 30


state 2

    0 $accept: program $end .

    $default  accept


state 3

    7 var_decl: LET . IDENT COLON type opt_init SEMI

    IDENT  shift, and go to state 31


state 4

    8 const_decl: CONST . IDENT COLON type ASSIGN expression SEMI

    IDENT  shift, and go to state 32


state 5

   29 if_stmt: IF . LPAREN expression RPAREN statement
   30        | IF . LPAREN expression RPAREN statement ELSE statement

    LPAREN  shift, and go to state 33


state 6

   31 while_stmt: WHILE . LPAREN expression RPAREN statement

    LPAREN  shift, and go to state 34


state 7

   32 for_stmt: FOR . LPAREN for_init SEMI opt_expr SEMI opt_expr RPAREN statement

    LPAREN  shift, and go to state 35


state 8

   20 statement: BREAK . SEMI

    SEMI  shift, and go to state 36


state 9

   21 statement: CONTINUE . SEMI

    SEMI  shift, and go to state 37


state 10

   38 io_stmt: PRINT . LPAREN expression RPAREN SEMI

    LPAREN  shift, and go to state 38


state 11

   39 io_stmt: OUT . LPAREN expression RPAREN SEMI

    LPAREN  shift, and go to state 39


state 12

   40 io_stmt: READ . LPAREN sensor_ref RPAREN SEMI

    LPAREN  shift, and go to state 40


state 13

   41 event_stmt: EVERY . INT_LIT MS block

    INT_LIT  shift, and go to state 41


state 14

   42 event_stmt: WHEN . LPAREN expression RPAREN block

    LPAREN  shift, and go to state 42


state 15

   28 lvalue: IDENT .

    $default  reduce using rule 28 (lvalue)


state 16

   23 block: LBRACE . block_items RBRACE

    $default  reduce using rule 24 (block_items)

    block_items  go to state 43


state 17

   22 statement: SEMI .

    $default  reduce using rule 22 (statement)


state 18

    2 program: program item .

    $default  reduce using rule 2 (program)


state 19

    3 item: declaration .

    $default  reduce using rule 3 (item)


state 20

    5 declaration: var_decl .

    $default  reduce using rule 5 (declaration)


state 21

    6 declaration: const_decl .

    $default  reduce using rule 6 (declaration)


state 22

    4 item: statement .

    $default  reduce using rule 4 (item)


state 23

   13 statement: block .

    $default  reduce using rule 13 (statement)


state 24

   14 statement: assign . SEMI

    SEMI  shift, and go to state 44


state 25

   27 assign: lvalue . ASSIGN expression

    ASSIGN  shift, and go to state 45


state 26

   15 statement: if_stmt .

    $default  reduce using rule 15 (statement)


state 27

   16 statement: while_stmt .

    $default  reduce using rule 16 (statement)


state 28

   17 statement: for_stmt .

    $default  reduce using rule 17 (statement)


state 29

   18 statement: io_stmt .

    $default  reduce using rule 18 (statement)


state 30

   19 statement: event_stmt .

    $default  reduce using rule 19 (statement)


state 31

    7 var_decl: LET IDENT . COLON type opt_init SEMI

    COLON  shift, and go to state 46


state 32

    8 const_decl: CONST IDENT . COLON type ASSIGN expression SEMI

    COLON  shift, and go to state 47


state 33

   29 if_stmt: IF LPAREN . expression RPAREN statement
   30        | IF LPAREN . expression RPAREN statement ELSE statement

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    expression      go to state 59
    logical_or      go to state 60
    logical_and     go to state 61
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 34

   31 while_stmt: WHILE LPAREN . expression RPAREN statement

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    expression      go to state 68
    logical_or      go to state 60
    logical_and     go to state 61
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 35

   32 for_stmt: FOR LPAREN . for_init SEMI opt_expr SEMI opt_expr RPAREN statement

    LET    shift, and go to state 69
    IDENT  shift, and go to state 15

    $default  reduce using rule 33 (for_init)

    lvalue    go to state 70
    for_init  go to state 71


state 36

   20 statement: BREAK SEMI .

    $default  reduce using rule 20 (statement)


state 37

   21 statement: CONTINUE SEMI .

    $default  reduce using rule 21 (statement)


state 38

   38 io_stmt: PRINT LPAREN . expression RPAREN SEMI

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    expression      go to state 72
    logical_or      go to state 60
    logical_and     go to state 61
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 39

   39 io_stmt: OUT LPAREN . expression RPAREN SEMI

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    expression      go to state 73
    logical_or      go to state 60
    logical_and     go to state 61
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 40

   40 io_stmt: READ LPAREN . sensor_ref RPAREN SEMI

    TEMP      shift, and go to state 50
    DOOROPEN  shift, and go to state 51
    CLOCK_MS  shift, and go to state 52

    sensor_ref  go to state 74


state 41

   41 event_stmt: EVERY INT_LIT . MS block

    MS  shift, and go to state 75


state 42

   42 event_stmt: WHEN LPAREN . expression RPAREN block

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    expression      go to state 76
    logical_or      go to state 60
    logical_and     go to state 61
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 43

   23 block: LBRACE block_items . RBRACE
   25 block_items: block_items . declaration
   26            | block_items . statement

    LET       shift, and go to state 3
    CONST     shift, and go to state 4
    IF        shift, and go to state 5
    WHILE     shift, and go to state 6
    FOR       shift, and go to state 7
    BREAK     shift, and go to state 8
    CONTINUE  shift, and go to state 9
    PRINT     shift, and go to state 10
    OUT       shift, and go to state 11
    READ      shift, and go to state 12
    EVERY     shift, and go to state 13
    WHEN      shift, and go to state 14
    IDENT     shift, and go to state 15
    LBRACE    shift, and go to state 16
    RBRACE    shift, and go to state 77
    SEMI      shift, and go to state 17

    declaration  go to state 78
    var_decl     go to state 20
    const_decl   go to state 21
    statement    go to state 79
    block        go to state 23
    assign       go to state 24
    lvalue       go to state 25
    if_stmt      go to state 26
    while_stmt   go to state 27
    for_stmt     go to state 28
    io_stmt      go to state 29
    event_stmt   go to state 30


state 44

   14 statement: assign SEMI .

    $default  reduce using rule 14 (statement)


state 45

   27 assign: lvalue ASSIGN . expression

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    expression      go to state 80
    logical_or      go to state 60
    logical_and     go to state 61
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 46

    7 var_decl: LET IDENT COLON . type opt_init SEMI

    KW_INT   shift, and go to state 81
    KW_BOOL  shift, and go to state 82

    type  go to state 83


state 47

    8 const_decl: CONST IDENT COLON . type ASSIGN expression SEMI

    KW_INT   shift, and go to state 81
    KW_BOOL  shift, and go to state 82

    type  go to state 84


state 48

   70 primary: TRUE_LIT .

    $default  reduce using rule 70 (primary)


state 49

   71 primary: FALSE_LIT .

    $default  reduce using rule 71 (primary)


state 50

   43 sensor_ref: TEMP .

    $default  reduce using rule 43 (sensor_ref)


state 51

   44 sensor_ref: DOOROPEN .

    $default  reduce using rule 44 (sensor_ref)


state 52

   45 sensor_ref: CLOCK_MS .

    $default  reduce using rule 45 (sensor_ref)


state 53

   72 primary: IDENT .

    $default  reduce using rule 72 (primary)


state 54

   69 primary: INT_LIT .

    $default  reduce using rule 69 (primary)


state 55

   68 unary: MINUS . unary

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref  go to state 58
    unary       go to state 85
    primary     go to state 67


state 56

   67 unary: NOT . unary

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref  go to state 58
    unary       go to state 86
    primary     go to state 67


state 57

   74 primary: LPAREN . expression RPAREN

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    expression      go to state 87
    logical_or      go to state 60
    logical_and     go to state 61
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 58

   73 primary: sensor_ref .

    $default  reduce using rule 73 (primary)


state 59

   29 if_stmt: IF LPAREN expression . RPAREN statement
   30        | IF LPAREN expression . RPAREN statement ELSE statement

    RPAREN  shift, and go to state 88


state 60

   46 expression: logical_or .
   48 logical_or: logical_or . OR logical_and

    OR  shift, and go to state 89

    $default  reduce using rule 46 (expression)


state 61

   47 logical_or: logical_and .
   50 logical_and: logical_and . AND equality

    AND  shift, and go to state 90

    $default  reduce using rule 47 (logical_or)


state 62

   49 logical_and: equality .
   52 equality: equality . EQ relational
   53         | equality . NEQ relational

    EQ   shift, and go to state 91
    NEQ  shift, and go to state 92

    $default  reduce using rule 49 (logical_and)


state 63

   51 equality: relational .
   55 relational: relational . LT additive
   56           | relational . LE additive
   57           | relational . GT additive
   58           | relational . GE additive

    LE  shift, and go to state 93
    GE  shift, and go to state 94
    LT  shift, and go to state 95
    GT  shift, and go to state 96

    $default  reduce using rule 51 (equality)


state 64

   54 relational: additive .
   60 additive: additive . PLUS multiplicative
   61         | additive . MINUS multiplicative

    PLUS   shift, and go to state 97
    MINUS  shift, and go to state 98

    $default  reduce using rule 54 (relational)


state 65

   59 additive: multiplicative .
   63 multiplicative: multiplicative . STAR unary
   64               | multiplicative . SLASH unary
   65               | multiplicative . MOD unary

    STAR   shift, and go to state 99
    SLASH  shift, and go to state 100
    MOD    shift, and go to state 101

    $default  reduce using rule 59 (additive)


state 66

   62 multiplicative: unary .

    $default  reduce using rule 62 (multiplicative)


state 67

   66 unary: primary .

    $default  reduce using rule 66 (unary)


state 68

   31 while_stmt: WHILE LPAREN expression . RPAREN statement

    RPAREN  shift, and go to state 102


state 69

   34 for_init: LET . IDENT COLON type opt_init

    IDENT  shift, and go to state 103


state 70

   35 for_init: lvalue . ASSIGN expression

    ASSIGN  shift, and go to state 104


state 71

   32 for_stmt: FOR LPAREN for_init . SEMI opt_expr SEMI opt_expr RPAREN statement

    SEMI  shift, and go to state 105


state 72

   38 io_stmt: PRINT LPAREN expression . RPAREN SEMI

    RPAREN  shift, and go to state 106


state 73

   39 io_stmt: OUT LPAREN expression . RPAREN SEMI

    RPAREN  shift, and go to state 107


state 74

   40 io_stmt: READ LPAREN sensor_ref . RPAREN SEMI

    RPAREN  shift, and go to state 108


state 75

   41 event_stmt: EVERY INT_LIT MS . block

    LBRACE  shift, and go to state 16

    block  go to state 109


state 76

   42 event_stmt: WHEN LPAREN expression . RPAREN block

    RPAREN  shift, and go to state 110


state 77

   23 block: LBRACE block_items RBRACE .

    $default  reduce using rule 23 (block)


state 78

   25 block_items: block_items declaration .

    $default  reduce using rule 25 (block_items)


state 79

   26 block_items: block_items statement .

    $default  reduce using rule 26 (block_items)


state 80

   27 assign: lvalue ASSIGN expression .

    $default  reduce using rule 27 (assign)


state 81

    9 type: KW_INT .

    $default  reduce using rule 9 (type)


state 82

   10 type: KW_BOOL .

    $default  reduce using rule 10 (type)


state 83

    7 var_decl: LET IDENT COLON type . opt_init SEMI

    ASSIGN  shift, and go to state 111

    $default  reduce using rule 11 (opt_init)

    opt_init  go to state 112


state 84

    8 const_decl: CONST IDENT COLON type . ASSIGN expression SEMI

    ASSIGN  shift, and go to state 113


state 85

   68 unary: MINUS unary .

    $default  reduce using rule 68 (unary)


state 86

   67 unary: NOT unary .

    $default  reduce using rule 67 (unary)


state 87

   74 primary: LPAREN expression . RPAREN

    RPAREN  shift, and go to state 114


state 88

   29 if_stmt: IF LPAREN expression RPAREN . statement
   30        | IF LPAREN expression RPAREN . statement ELSE statement

    IF        shift, and go to state 5
    WHILE     shift, and go to state 6
    FOR       shift, and go to state 7
    BREAK     shift, and go to state 8
    CONTINUE  shift, and go to state 9
    PRINT     shift, and go to state 10
    OUT       shift, and go to state 11
    READ      shift, and go to state 12
    EVERY     shift, and go to state 13
    WHEN      shift, and go to state 14
    IDENT     shift, and go to state 15
    LBRACE    shift, and go to state 16
    SEMI      shift, and go to state 17

    statement   go to state 115
    block       go to state 23
    assign      go to state 24
    lvalue      go to state 25
    if_stmt     go to state 26
    while_stmt  go to state 27
    for_stmt    go to state 28
    io_stmt     go to state 29
    event_stmt  go to state 30


state 89

   48 logical_or: logical_or OR . logical_and

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    logical_and     go to state 116
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 90

   50 logical_and: logical_and AND . equality

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    equality        go to state 117
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 91

   52 equality: equality EQ . relational

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    relational      go to state 118
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 92

   53 equality: equality NEQ . relational

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    relational      go to state 119
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 93

   56 relational: relational LE . additive

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    additive        go to state 120
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 94

   58 relational: relational GE . additive

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    additive        go to state 121
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 95

   55 relational: relational LT . additive

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    additive        go to state 122
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 96

   57 relational: relational GT . additive

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    additive        go to state 123
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 97

   60 additive: additive PLUS . multiplicative

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    multiplicative  go to state 124
    unary           go to state 66
    primary         go to state 67


state 98

   61 additive: additive MINUS . multiplicative

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    multiplicative  go to state 125
    unary           go to state 66
    primary         go to state 67


state 99

   63 multiplicative: multiplicative STAR . unary

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref  go to state 58
    unary       go to state 126
    primary     go to state 67


state 100

   64 multiplicative: multiplicative SLASH . unary

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref  go to state 58
    unary       go to state 127
    primary     go to state 67


state 101

   65 multiplicative: multiplicative MOD . unary

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref  go to state 58
    unary       go to state 128
    primary     go to state 67


state 102

   31 while_stmt: WHILE LPAREN expression RPAREN . statement

    IF        shift, and go to state 5
    WHILE     shift, and go to state 6
    FOR       shift, and go to state 7
    BREAK     shift, and go to state 8
    CONTINUE  shift, and go to state 9
    PRINT     shift, and go to state 10
    OUT       shift, and go to state 11
    READ      shift, and go to state 12
    EVERY     shift, and go to state 13
    WHEN      shift, and go to state 14
    IDENT     shift, and go to state 15
    LBRACE    shift, and go to state 16
    SEMI      shift, and go to state 17

    statement   go to state 129
    block       go to state 23
    assign      go to state 24
    lvalue      go to state 25
    if_stmt     go to state 26
    while_stmt  go to state 27
    for_stmt    go to state 28
    io_stmt     go to state 29
    event_stmt  go to state 30


state 103

   34 for_init: LET IDENT . COLON type opt_init

    COLON  shift, and go to state 130


state 104

   35 for_init: lvalue ASSIGN . expression

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    expression      go to state 131
    logical_or      go to state 60
    logical_and     go to state 61
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 105

   32 for_stmt: FOR LPAREN for_init SEMI . opt_expr SEMI opt_expr RPAREN statement

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    $default  reduce using rule 36 (opt_expr)

    opt_expr        go to state 132
    sensor_ref      go to state 58
    expression      go to state 133
    logical_or      go to state 60
    logical_and     go to state 61
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 106

   38 io_stmt: PRINT LPAREN expression RPAREN . SEMI

    SEMI  shift, and go to state 134


state 107

   39 io_stmt: OUT LPAREN expression RPAREN . SEMI

    SEMI  shift, and go to state 135


state 108

   40 io_stmt: READ LPAREN sensor_ref RPAREN . SEMI

    SEMI  shift, and go to state 136


state 109

   41 event_stmt: EVERY INT_LIT MS block .

    $default  reduce using rule 41 (event_stmt)


state 110

   42 event_stmt: WHEN LPAREN expression RPAREN . block

    LBRACE  shift, and go to state 16

    block  go to state 137


state 111

   12 opt_init: ASSIGN . expression

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    expression      go to state 138
    logical_or      go to state 60
    logical_and     go to state 61
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 112

    7 var_decl: LET IDENT COLON type opt_init . SEMI

    SEMI  shift, and go to state 139


state 113

    8 const_decl: CONST IDENT COLON type ASSIGN . expression SEMI

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    sensor_ref      go to state 58
    expression      go to state 140
    logical_or      go to state 60
    logical_and     go to state 61
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 114

   74 primary: LPAREN expression RPAREN .

    $default  reduce using rule 74 (primary)


state 115

   29 if_stmt: IF LPAREN expression RPAREN statement .
   30        | IF LPAREN expression RPAREN statement . ELSE statement

    ELSE  shift, and go to state 141

    $default  reduce using rule 29 (if_stmt)


state 116

   48 logical_or: logical_or OR logical_and .
   50 logical_and: logical_and . AND equality

    AND  shift, and go to state 90

    $default  reduce using rule 48 (logical_or)


state 117

   50 logical_and: logical_and AND equality .
   52 equality: equality . EQ relational
   53         | equality . NEQ relational

    EQ   shift, and go to state 91
    NEQ  shift, and go to state 92

    $default  reduce using rule 50 (logical_and)


state 118

   52 equality: equality EQ relational .
   55 relational: relational . LT additive
   56           | relational . LE additive
   57           | relational . GT additive
   58           | relational . GE additive

    LE  shift, and go to state 93
    GE  shift, and go to state 94
    LT  shift, and go to state 95
    GT  shift, and go to state 96

    $default  reduce using rule 52 (equality)


state 119

   53 equality: equality NEQ relational .
   55 relational: relational . LT additive
   56           | relational . LE additive
   57           | relational . GT additive
   58           | relational . GE additive

    LE  shift, and go to state 93
    GE  shift, and go to state 94
    LT  shift, and go to state 95
    GT  shift, and go to state 96

    $default  reduce using rule 53 (equality)


state 120

   56 relational: relational LE additive .
   60 additive: additive . PLUS multiplicative
   61         | additive . MINUS multiplicative

    PLUS   shift, and go to state 97
    MINUS  shift, and go to state 98

    $default  reduce using rule 56 (relational)


state 121

   58 relational: relational GE additive .
   60 additive: additive . PLUS multiplicative
   61         | additive . MINUS multiplicative

    PLUS   shift, and go to state 97
    MINUS  shift, and go to state 98

    $default  reduce using rule 58 (relational)


state 122

   55 relational: relational LT additive .
   60 additive: additive . PLUS multiplicative
   61         | additive . MINUS multiplicative

    PLUS   shift, and go to state 97
    MINUS  shift, and go to state 98

    $default  reduce using rule 55 (relational)


state 123

   57 relational: relational GT additive .
   60 additive: additive . PLUS multiplicative
   61         | additive . MINUS multiplicative

    PLUS   shift, and go to state 97
    MINUS  shift, and go to state 98

    $default  reduce using rule 57 (relational)


state 124

   60 additive: additive PLUS multiplicative .
   63 multiplicative: multiplicative . STAR unary
   64               | multiplicative . SLASH unary
   65               | multiplicative . MOD unary

    STAR   shift, and go to state 99
    SLASH  shift, and go to state 100
    MOD    shift, and go to state 101

    $default  reduce using rule 60 (additive)


state 125

   61 additive: additive MINUS multiplicative .
   63 multiplicative: multiplicative . STAR unary
   64               | multiplicative . SLASH unary
   65               | multiplicative . MOD unary

    STAR   shift, and go to state 99
    SLASH  shift, and go to state 100
    MOD    shift, and go to state 101

    $default  reduce using rule 61 (additive)


state 126

   63 multiplicative: multiplicative STAR unary .

    $default  reduce using rule 63 (multiplicative)


state 127

   64 multiplicative: multiplicative SLASH unary .

    $default  reduce using rule 64 (multiplicative)


state 128

   65 multiplicative: multiplicative MOD unary .

    $default  reduce using rule 65 (multiplicative)


state 129

   31 while_stmt: WHILE LPAREN expression RPAREN statement .

    $default  reduce using rule 31 (while_stmt)


state 130

   34 for_init: LET IDENT COLON . type opt_init

    KW_INT   shift, and go to state 81
    KW_BOOL  shift, and go to state 82

    type  go to state 142


state 131

   35 for_init: lvalue ASSIGN expression .

    $default  reduce using rule 35 (for_init)


state 132

   32 for_stmt: FOR LPAREN for_init SEMI opt_expr . SEMI opt_expr RPAREN statement

    SEMI  shift, and go to state 143


state 133

   37 opt_expr: expression .

    $default  reduce using rule 37 (opt_expr)


state 134

   38 io_stmt: PRINT LPAREN expression RPAREN SEMI .

    $default  reduce using rule 38 (io_stmt)


state 135

   39 io_stmt: OUT LPAREN expression RPAREN SEMI .

    $default  reduce using rule 39 (io_stmt)


state 136

   40 io_stmt: READ LPAREN sensor_ref RPAREN SEMI .

    $default  reduce using rule 40 (io_stmt)


state 137

   42 event_stmt: WHEN LPAREN expression RPAREN block .

    $default  reduce using rule 42 (event_stmt)


state 138

   12 opt_init: ASSIGN expression .

    $default  reduce using rule 12 (opt_init)


state 139

    7 var_decl: LET IDENT COLON type opt_init SEMI .

    $default  reduce using rule 7 (var_decl)


state 140

    8 const_decl: CONST IDENT COLON type ASSIGN expression . SEMI

    SEMI  shift, and go to state 144


state 141

   30 if_stmt: IF LPAREN expression RPAREN statement ELSE . statement

    IF        shift, and go to state 5
    WHILE     shift, and go to state 6
    FOR       shift, and go to state 7
    BREAK     shift, and go to state 8
    CONTINUE  shift, and go to state 9
    PRINT     shift, and go to state 10
    OUT       shift, and go to state 11
    READ      shift, and go to state 12
    EVERY     shift, and go to state 13
    WHEN      shift, and go to state 14
    IDENT     shift, and go to state 15
    LBRACE    shift, and go to state 16
    SEMI      shift, and go to state 17

    statement   go to state 145
    block       go to state 23
    assign      go to state 24
    lvalue      go to state 25
    if_stmt     go to state 26
    while_stmt  go to state 27
    for_stmt    go to state 28
    io_stmt     go to state 29
    event_stmt  go to state 30


state 142

   34 for_init: LET IDENT COLON type . opt_init

    ASSIGN  shift, and go to state 111

    $default  reduce using rule 11 (opt_init)

    opt_init  go to state 146


state 143

   32 for_stmt: FOR LPAREN for_init SEMI opt_expr SEMI . opt_expr RPAREN statement

    TRUE_LIT   shift, and go to state 48
    FALSE_LIT  shift, and go to state 49
    TEMP       shift, and go to state 50
    DOOROPEN   shift, and go to state 51
    CLOCK_MS   shift, and go to state 52
    IDENT      shift, and go to state 53
    INT_LIT    shift, and go to state 54
    MINUS      shift, and go to state 55
    NOT        shift, and go to state 56
    LPAREN     shift, and go to state 57

    $default  reduce using rule 36 (opt_expr)

    opt_expr        go to state 147
    sensor_ref      go to state 58
    expression      go to state 133
    logical_or      go to state 60
    logical_and     go to state 61
    equality        go to state 62
    relational      go to state 63
    additive        go to state 64
    multiplicative  go to state 65
    unary           go to state 66
    primary         go to state 67


state 144

    8 const_decl: CONST IDENT COLON type ASSIGN expression SEMI .

    $default  reduce using rule 8 (const_decl)


state 145

   30 if_stmt: IF LPAREN expression RPAREN statement ELSE statement .

    $default  reduce using rule 30 (if_stmt)


state 146

   34 for_init: LET IDENT COLON type opt_init .

    $default  reduce using rule 34 (for_init)


state 147

   32 for_stmt: FOR LPAREN for_init SEMI opt_expr SEMI opt_expr . RPAREN statement

    RPAREN  shift, and go to state 148


state 148

   32 for_stmt: FOR LPAREN for_init SEMI opt_expr SEMI opt_expr RPAREN . statement

    IF        shift, and go to state 5
    WHILE     shift, and go to state 6
    FOR       shift, and go to state 7
    BREAK     shift, and go to state 8
    CONTINUE  shift, and go to state 9
    PRINT     shift, and go to state 10
    OUT       shift, and go to state 11
    READ      shift, and go to state 12
    EVERY     shift, and go to state 13
    WHEN      shift, and go to state 14
    IDENT     shift, and go to state 15
    LBRACE    shift, and go to state 16
    SEMI      shift, and go to state 17

    statement   go to state 149
    block       go to state 23
    assign      go to state 24
    lvalue      go to state 25
    if_stmt     go to state 26
    while_stmt  go to state 27
    for_stmt    go to state 28
    io_stmt     go to state 29
    event_stmt  go to state 30


state 149

   32 for_stmt: FOR LPAREN for_init SEMI opt_expr SEMI opt_expr RPAREN statement .

    $default  reduce using rule 32 (for_stmt)
